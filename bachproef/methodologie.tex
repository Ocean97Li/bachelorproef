%%=============================================================================
%% Methodologie
%%=============================================================================

\chapter{Methodologie}
\label{ch:methodologie}

%% TODO: Hoe ben je te werk gegaan? Verdeel je onderzoek in grote fasen, en
%% licht in elke fase toe welke stappen je gevolgd hebt. Verantwoord waarom je
%% op deze manier te werk gegaan bent. Je moet kunnen aantonen dat je de best
%% mogelijke manier toegepast hebt om een antwoord te vinden op de
%% onderzoeksvraag.
Na het voeren van een brede literatuurstudie in hoofstuk \ref{ch:stand-van-zaken} die  alle contextuele informatie verschaft betreffende het onderwerp \textit{blockchain-gebaseerde stemsystemen}, zal deze scriptie zich nu toespitsen op de implementatie van een dergelijk systeem. Deze implementatie en de beschrijving er van vormen de  \textit{proof-of-concept} van deze scriptie.

 Dit hoofdstuk beschrijft de werkwijzen, procedures en methoden die gevolgd werden om de  proof-of-concept van deze scriptie op te realiseren. De proof-of-concept zelf vindt men terug in de vorm van een praktische handleiding in hoofdstuk \ref{ch:handleiding}, als ook in de vorm van een project waarvan de broncode kan gevonden worden in de bijlagen.
 
 Gezien het doel van de handleiding is om een volledig beeld te geven van de implementatie, door bijvoorbeeld het belichten van de verschillende technische praktische moeilijkheden, zijn veel van de zaken betreffende de werkwijze opgenomen in het volgende hoofdstuk ten gunste van dit hoofdstuk. Het doel van dit hoofdstuk is voornamelijk om het proces dat tot de realisatie en formulering van de handleiding geleid heeft te duiden. Tot dat doeleinde wordt de methodologie opgedeeld in drie verschillende delen:

Deel 1 beschrijft en vergelijkt in het kort de verschillende implementaties die als bronnen dienden voor het project van deze scriptie.

Deel 2 beschrijft de werkwijze en de problemen die ondervonden werden tijdens het implementeren van het back-end project.

Deel 3 beschrijft in het kort de werkwijze en problemen bij de implementatie van het front-end project.

\section{Bronnen}
	\subsection{Boeken}
	Bij gebrek aan ontwikkelervaring binnen Ethereum begon het realiseren van de proof-of-concept met het leren van de programmeertaal \textit{Solidity}. Vermits dit een taal is die syntactisch erg gelijkaardig is aan het bekende JavaScript, verliep dit proces vrij vlot. Het werk van \textcite{Antonopoulos2018} vormde een stevige basis om de taal te leren.
	
	Met de kennis van Solidity begon het experimenteren met een stemsysteem op basis van een smart-contract. Het werk van \textcite{Mukhopadhyay2018} vormde daarvoor de eerste bron van inspiratie, maar werd geleidelijk aan vervangen door andere werken.
	
	\subsection{DappUniversity en Walking Tree Technologies}
	Voor de uiteindelijke proof-of-concept vormt de DappUniversity implementatie van \textcite{McCubin2019}  de voornaamste bron van inspiratie. De hoofdreden dat \textcite{McCubin2019} binnen deze scriptie de voorkeur geniet is omdat  het veruit het meest recente werk is binnen de literatuur. De code is geschreven in de laatste stabiele versie van Solidity\footnote{Solidity v0.5.8 in Juni 2019}. In een nog niet zo mature ontwikkelomgeving als Ethereum is dat van cruciaal belang. Het up-to-date blijven van de code is erg belangrijk, vermits het netwerk  en de taal geregeld nog drastische veranderingen ondergaan kan er een groot potentieel aan performantie verloren gaan bij  gebruik van verouderde versies. Daarnaast vormt \textcite{McCubin2019} ook het perfecte startpunt met een relatief eenvoudig, maar vooral ook compact smart-contract. Complementair aan het werk van \textcite{McCubin2019} wordt de Walking Tree Technologies implementatie van \textcite{Ranjan2018} gebruikt om de connectie te maken tussen Ethereum en een front-end Angular project.
	
	\subsection{Open Vote Network Protocol}
	Het OVNP van \textcite{McCorry2017} werd reeds uitvoerig behandeld in sectie \ref{sec:OVNP} van het vorige hoofdstuk. Met dit protocol laat \textcite{McCorry2017} zich gelden als een van de meest secure werken in de literatuur. Het kent echter ook verschillende nadelen. Zo is er bijvoorbeeld, in het streven naar absolute veiligheid een stuk gebruiksvriendelijkheid dat verloren gaat. Een ander nadeel is dat de implementatie het Ethereum platform tot zijn absolute maxima duwt. Ethereum is maar net instaat om het OVNP te draaien, er zijn maar liefst twee contracten voor nodig, waarin er gebruik  gemaakt wordt van complexe externe cryptografie bibliotheken bij gebrek aan native support. Deze dependencies zorgen ervoor dat het OVNP gevoelig is aan Ethereum updates. Toch ziet deze scriptie het werk van \textcite{McCorry2017} als de gouden standaard voor veilige, volledig anonieme blockchain gebaseerd stemsystemen. In de praktijk blijkt het echter moeilijk om de OVNP zelf aan te wenden in een implementatie...
	
\section{Back-end project}
	\subsection{Verloop van opzet en implementatie}
	De opzet en initiële implementatie van het \textit{Election.sol} smart-contract verliepen grotendeels zoals voorgeschreven door \textcite{McCubin2019}. Dit alles verliep naadloos. Toen de functionaliteit moest worden uitgebreid met beveiligingsmechanismen kwamen er echter enkele problemen aan het licht.
	
	\subsection{Ondervonden Problemen}
	Een van de moeilijkheden waarmee men te maken krijgt tijdens ontwikkelen van gedecentraliseerde applicaties binnen Ethereum, is het feit dat het zeer moeilijk is om anonimiteit of privacy voor gebruikers te creëren. De aard van de blockchain-technologie zelf legt immers de nadruk op het publiek beschikbaar maken van alle gegevens. Ook in Ethereum is deze filosofie sterk aanwezig, iedere transactie en al de daar bijhorende parameters is publiek. Eigenlijk is alles publiek binnen de Ethereum-blockchain. Private attributen en methoden in smart-contracts mogen dan wel bestaan, de waarden zullen nog steeds publiek leesbaar zijn. \autocite{Buterin2014}
	
	Voor deze scriptie vormde dit een potentieel probleem. Gezien iedere stem als parameter door gegeven wordt, betekent dit dat het stemgedrag van ieder adres zichtbaar is. Op het vlak van stemsystemen is anonimiteit van kiezers  echter vaak noodzakelijk. Gezien Ethereum geen private transacties ondersteund (sommige blockchains doen dit wel)  moest er simpelweg op zoek gegaan worden naar alternatieve methodes. 
	
	Het leek een logische volgende stap om te kijken of  de stemmen die werd doorgeven als parameters niet simpelweg kon worden verborgen door ze te encrypteren. Het probleem was hiermee was dat ook standaard encryptie en decryptie technieken niet werken op de Ethereum blockchain: We kunnen geen enkel geheim bewaren op, of doorsturen naar de blockchain. Stemmen geëncrypteerd verzenden en vervolgens, op het einde van de verkiezing alle stemmen bekend maken door gebruikers hun decryptie sleutel te laten bekend maken (het veelgebruikte commit-reveal pattern) werkt niet in deze specifieke context. Er is immers tot op heden\footnote{Off-chain transacties zouden dit misschien wel mogelijk maken, er is een kans dat deze zullen toegevoegd worden volgens de Ethereum Wiki \autocite{Buterin2014}} geen enkele manier om de decryptie sleutel geheim te houden. Zowel Decryptie sleutels onthouden in een smart-contract als de sleutel versturen via een transactie resulteert dus in hetzelfde: De sleutel is zichtbaar op de blockchain en kan gebruikt worden om op directe wijze het stemgedrag van de kiezer in kwestie af te weten te komen.
	
	Indien men ook maar enige vorm van gegarandeerde anonimiteit wilt aanbieden, is er dus geen andere keuze dan gebruik te maken van zeer geavanceerde cryptografische technieken. In dit geval grijpen we hier dus binaar de cryptografische techniek die we reeds bespraken in het vorige hoofdstuk: het OVNP van \textcite{McCorry2017}. 
		
	In de praktijk bleek het gebruik maken hiervan moeilijker dan gedacht. 
	
	 Het OVNP van \textcite{McCorry2017} mag dan wel volledig open-source als een bibliotheek worden aangeboden, het probleem is dat de codebasis niet meer werd geüpgedate sinds 23 Augustus 2017\footnote{Zie https://github.com/stonecoldpat/anonymousvoting/commits/masters}. Sinds die tijd is de werking van Solidity en het Ethereum netwerk zodanig  veranderd dat de code in deze vorm noch compatibel met, noch performant ten opzichte van huidige Ethereum implementaties is. 
	 
	 In functie van dit onderzoek werd een poging ondernomen om de implementatie de herschrijven, maar dit bleek al gauw buiten de scope van deze scriptie te vallen. Ten gevolge hiervan, voldoet de door deze scriptie gepresenteerde oplossing niet aan wat \textcite{McCorry2017} en \textcite{Kiayias2002} \textit{perfect ballot secrecy} noemen.

\section{Front-end project}
	\subsection{Verloop van opzet en implementatie}
	Het verloop van de front-end implementatie gebeurde eerst grotendeels op basis van het werk van \textcite{Ranjan2018} en
	in mindere mate ook het werk van \textcite{McCubin2019}. Deze werken werden alleen gebruikt bij het implementeren van de \textit{EthereumConnectionService.ts}. 
	
	Voor de rest van de applicatie werd met de vrijes hand een ontwerp ontwikkeld dat zich ietwat liet inspireren door de visuele stijl van de OVNP implementatie van \textcite{McCorry2017}.
	\subsection{Ondervonden Problemen}
	De enigste problemen die opkwamen bij het front-end project waren gerelateerd aan de \textit{web3 node\_module}. 
	
	Verschillende door web3 gebruikte node packages konden niet gevonden worden. Na enig onderzoek werd duidelijk dat het probleem in kwestie over een incompatibiliteit ging tussen de huidige web3 (1.0.0-beta)en de nieuwere Angular versies (6+). De  eerste oplossing bestond eruit de web3 versie te verlagen naar een meer stabiele versie. In dit geval was dat  versie v0.20.5. 
	
	Bij de hereninstallatie van de node\_modules van het project begon het probleem echter opnieuw voor te komen, tot dat doeleinde werd de voorgestelde oplossing\footnote{Zie https://gist.github.com/niespodd/1fa82da6f8c901d1c33d2fcbb762947d} gebruikt om een custom patch file te schrijven. Met de toevoeging van deze patch file (zie patch.js) voor de installatie van alle node modules kunnen alle op de verwachte locatie ontbrekende packages gesubstitueerd door de pakketten op de werkelijke locatie.
	
	
